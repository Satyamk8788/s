#include<stdio.h>
#include<GL/glut.h>
#include<stdbool.h>
doublexmin=50,ymin=50,xmax=100,ymax=100;//Windowboundaries
doublexvmin=200,yvmin=200,xvmax=300,yvmax=300;//Viewportboundaries
//bitcodesfortheright,left,top,&bottom
constintTOP=8;
constintBOTTOM=4;
constintRIGHT=2;
constintLEFT=1;
//usedtocomputebitcodesofaintersectingpoint
intComputeOutCode(doublex,doubley);
//Cohen-Sutherlandclippingalgorithmclipsalinefrom
//P0=(x0,y0)toP1=(x1,y1)againstarectanglewith
//diagonalfrom(xmin,ymin)to(xmax,ymax).
voidCohenSutherlandLineClipAndDraw(doublex0,doubley0,doublex1,doubley1)
{
//OutcodesforP0,P1,andwhateverpointliesoutsidethecliprectangle
intoutcode0,outcode1,outcodeOut;
boolaccept=false,done=false;
outcode0=ComputeOutCode(x0,y0);
outcode1=ComputeOutCode(x1,y1);
do
{
if((outcode0|outcode1)==0)//logicaloris0Triviallyaccept&exit
{
accept=true;
done=true;
}
elseif(outcode0&outcode1)//logicalandisnot0.Triviallyrejectandexit
done=true;
else
{
//failedbothtests,socalculatethelinesegmenttoclip
//fromanoutsidepointtoanintersectionwithclipedge
doublex,y;
//Atleastoneendpointisoutsidethecliprectangle;pickit.
outcodeOut=outcode0?outcode0:outcode1;
floatslope=(y1-y0)/(x1-x0);
//Nowfindtheintersectionpoint;
//useformulasy=y0+slope*(x-x0),x=x0+(1/slope)*(y-y0)
if(outcodeOut&TOP)//pointisabovethecliprectangle
{
x=x0+(1/slope)*(ymax-y0);
y=ymax;
}
elseif(outcodeOut&BOTTOM)//pointisbelowthecliprectangle
{
x=x0+(1/slope)*(ymin-y0);
y=ymin;
}
elseif(outcodeOut&RIGHT)//pointistotherightofcliprectangle
{
y=y0+slope*(xmax-x0);
x=xmax;
}
else//pointistotheleftofcliprectangle
{
y=y0+slope*(xmin-x0);
x=xmin;
}if(outcodeOut==outcode0)
{
x0=x;
y0=y;
outcode0=ComputeOutCode(x0,y0);
}
else
{
x1=x;
y1=y;
outcode1=ComputeOutCode(x1,y1);
}
}
}
while(!done);
if(accept)
{
//Windowtoviewportmappings
doublesx=(xvmax-xvmin)/(xmax-xmin);//Scaleparameters
doublesy=(yvmax-yvmin)/(ymax-ymin);
doublevx0=xvmin+(x0-xmin)*sx;
doublevy0=yvmin+(y0-ymin)*sy;
doublevx1=xvmin+(x1-xmin)*sx;
doublevy1=yvmin+(y1-ymin)*sy;
//drawaredcoloredviewport
glColor3f(1.0,0.0,0.0);
glBegin(GL_LINE_LOOP);
glVertex2f(xvmin,yvmin);
glVertex2f(xvmax,yvmin);
glVertex2f(xvmax,yvmax);
glVertex2f(xvmin,yvmax);
glEnd();
glColor3f(0.0,0.0,1.0);//drawbluecoloredclippedline
glBegin(GL_LINES);
glVertex2d(vx0,vy0);
glVertex2d(vx1,vy1);
glEnd();
}
}
//Computethebitcodeforapoint(x,y)usingthecliprectangle
//boundeddiagonallyby(xmin,ymin),and(xmax,ymax)
intComputeOutCode(doublex,doubley)
{
intcode=0;
if(y>ymax)
code|=TOP;
elseif(y<ymin)//belowtheclipwindow
code|=BOTTOM;
if(x>xmax)//totherightofclipwindow
code|=RIGHT;
elseif(x<xmin)//totheleftofclipwindow
code|=LEFT;
returncode;
}
voiddisplay()
{
doublex0=60,y0=20,x1=80,y1=120;
glClear(GL_COLOR_BUFFER_BIT);
//drawthelinewithredcolor
glColor3f(1.0,0.0,0.0);
//bres(120,20,340,250);
glBegin(GL_LINES);
glVertex2d(x0,y0);
glVertex2d(x1,y1);
glEnd();
//drawabluecoloredwindow
glColor3f(0.0,0.0,1.0);
glBegin(GL_LINE_LOOP);
glVertex2f(xmin,ymin);
glVertex2f(xmax,ymin);
glVertex2f(xmax,ymax);
glVertex2f(xmin,ymax);
glEnd();
CohenSutherlandLineClipAndDraw(x0,y0,x1,y1);
glFlush();
}
voidmyinit()
{
glClearColor(1.0,1.0,1.0,1.0);
glColor3f(1.0,0.0,0.0);
glPointSize(1.0);
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
gluOrtho2D(0.0,499.0,0.0,499.0);
}
voidmain(intargc,char**argv)
{
glutInit(&argc,argv);
glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
glutInitWindowSize(500,500);
glutInitWindowPosition(0,0);
glutCreateWindow("CohenSuderlandLineClippingAlgorithm");
glutDisplayFunc(display);
myinit();
glutMainLoop();
}
